\documentclass[article,shortnames,nojss]{jss}
\usepackage{thumbpdf}

%% need no \usepackage{Sweave.sty}
\SweaveOpts{engine = R, strip.white = TRUE, keep.source = TRUE, eps = FALSE}

\newcommand{\class}[1]{`\code{#1}'}

%\VignetteIndexEntry{mefa4 Design Decisions}
%\VignettePackage{mefa4}
%\VignetteDepends{}
%\VignetteKeywords{biodiversity, biogeography, data manipulation, ecology, multivariate methods, R}

\author{P\'eter S\'olymos\\University of Alberta}
\Plainauthor{P\'eter S\'olymos}

\title{\pkg{mefa4} Design Decisions}
\Plaintitle{mefa4 Design Decisions}
\Shorttitle{\pkg{mefa4} Design Decisions}

\Abstract{
  \pkg{mefa4} is a reimplementation of the S3 object classes found in the \pkg{mefa} \proglang{R} package.
  The new S4 class \code{"Mefa"} has all the consistency checks that S3 classes
  cannot have, and most importantly, it stores the crosstabuted results as a compact
  sparse matrix (\code{"dgCMatrix"}). The use of sparse matrices speed up computations,
  and reduces object sizes considerably. This vignette introduces the main functions,
  classes and methods of the package \pkg{mefa4}.

  Processed with \pkg{mefa4} \Sexpr{packageDescription("mefa4", field="Version")} in \Sexpr{R.version.string} on \today.
}

\Keywords{biodiversity, biogeography, data manipulation, ecology, multivariate methods, \proglang{R}, sparse matrices}
\Plainkeywords{biodiversity, biogeography, data manipulation, ecology, multivariate methods, R, sparse matrices}

\Address{
  P\'eter S\'olymos\\
  Alberta Biodiversity Monitoring Institute\\
  and Boreal Avian Modelling project\\
  Department of Biological Sciences\\
  CW 405, Biological Sciences Bldg\\
  University of Alberta\\
  Edmonton, Alberta, T6G 2E9, Canada\\
  E-mail: \email{solymos@ualberta.ca}
}

\begin{document}


<<echo=FALSE, results=hide>>=
options(prompt = "R> ", continue = "+   ", useFancyQuotes = FALSE, width = 76)
@


\section{Introduction}

The aim of the \pkg{mefa} and \pkg{mefa4} packages are to help in storing cross tabulated
ecological data tables (community) data together with attributes for rows (samples) and columns
(species, taxa). This allows that one can easily subset the relational data object without
seperately manipulating 2--3 \proglang{R} objects. By doing so, the chances of errors are reduced.

As ecological data sets are increasing in size, it is necessary to find more efficient ways of
data storage and manipulation. To this end, it was in the air for some time to redesign
the \pkg{mefa} package and take advantages of sparse matrices from the \pkg{Matrix} package.
This is done at the costs of some old functionalities not being available for S4 classes.
Here I give an overview so the user can decide how to use the parallel availability
of old S3 and newer S4 classes.

\section{Comparison of S3 and S4 classes}

The S3 classes defined in \pkg{mefa} were \code{stcs} and \code{mefa}.
\code{stcs} is a data frame with several attributes:
<<>>=
library(mefa)
x <- data.frame(
    sample = paste("Sample", c(1,1,2,2,3,4), sep="."),
    species = c(paste("Species", c(1,1,1,2,3), sep="."),  "zero.pseudo"),
    count = c(1,2,10,3,4,0),
    segment = letters[c(6,13,6,13,6,6)])
x
samp <- data.frame(samples=levels(x$sample), var1=1:2)
taxa <- data.frame(specnames=levels(x$species), var2=c("b","a"))
rownames(samp) <- samp$samples
rownames(taxa) <- taxa$specnames
samp
taxa
s <- stcs(x)
attributes(s)
@
These attributes ensure that the crosstab made by the function \code{mefa()} creates a proper
crosstab by eliminating columns, etc:
<<>>=
(m <- mefa(s, samp, taxa))
m$xtab
@

The \code{stcs} step is almost redundant, and inefficient relative to the \code{Matrix:::xtabs}
function with \code{sparse = TRUE}. This function is adapted to some extant, so it can subset
the crosstabulated results befor returning the value (\code{rdrop} and \code{cdrop} arguments,
that is available as the \code{Xtab} function in the \pkg{mefa4} package. This takes a formula,
and can be applied directly on a data frame. The formula can have a left-hand side, or the left-hand side can be 
missing:
<<>>=
library(mefa4)
(x0 <- Xtab(~ sample + species, x))
(x1 <- Xtab(count ~ sample + species, x))
@
Dropping some rows/columns can be done in several ways.
A logical statement implies that all empty rows/columns are dropped,
but indices (numeric or character) can also be used:
<<>>=
(x2 <- Xtab(count ~ sample + species, x, cdrop=FALSE, rdrop=TRUE))
Xtab(count ~ sample + species, x, cdrop=TRUE, rdrop=FALSE)
Xtab(count ~ sample + species, x, cdrop="zero.pseudo")
@
The results here are sparse matrices in compact mode, meaning that
redundant indices are only kept once, so it is more compact than
a long formatted database representation stored in an \code{stcs}
object or in the original data frame. See vignettes in the 
\pkg{Matrix} package for more details on S4 sparse matrix classes.

The S4 class \code{"Mefa"} is defined in the \pkg{mefa4} package.
It can be created by the \code{Mefa()} function, and the result has 4 slots:
<<>>=
(x3 <- Mefa(x1, samp, taxa))
unclass(x3)
@
The \code{xtab} slot stores the crosstab in sparse matrix format.
The \code{samp} slot stores the row attributes for \code{xtab} or
can be \code{NULL}.
The \code{taxa} slot stores the column attributes for \code{xtab} or
can be \code{NULL}. Validity checks are done to ensure
proper object classes to be used and matching dimnames.
The option that a column in the attribute tables can be specified
to find matching names is not available in the new implementation.
Rownames of the data frames has to match dimnames of \code{xtab}.
The \code{joint} slot can be \code{"left"} (all rows/columns in the
\code{xtab} are kept, matching attributes are selected, non matching
attributes are excluded, and missing attributes are filled up with \codeNA})
or \code{"inner"} (only the intersection of corresponding dimnames are used to
form the return value).

The call in \code{Mefa()} can take any matrix or sparse matrix as argument,
but it will be stored in a sparse mode. Here we use a matrix as input,
and \code{samp} has missing values (\code{"left"} join is used by default):
<<>>=
(x4 <- Mefa(as.matrix(x1), samp[1:2,]))
unclass(x4)
@
The effect of \code{"inner"} join is as follows:
<<>>=
(x5 <- Mefa(x2, samp, taxa, join="inner"))
unclass(x5)
unclass(Mefa(x1, samp[1:2,], join="inner"))
@
A \code{"Mefa"} object with only \code{xtab} can also be defined:
<<>>=
(x6 <- Mefa(x1))
@

The structure of the S3 and S4 classes are very similar, and even the
accessor methods (\code{xtab()}, \code{samp()}, \code{taxa()}, \code{segm()})
work properly on both types. The S4 class does not have a slot for
a call, and there is no \code{segm} elemnt/slot as well. This means that
a \code{"Mefa"} object cannot have 3 dimanss, only 2. This might not be
a nice feature, and 3 dimensional S4 classes might be added in future releases.
Currently it is however, not a priority, as the gain in efficiency was the main
reason. For those who require 3D representation, the S3 classes should be
sufficient for the time being.

\section{Back and forth}

Coercion methods are defined in both the \pkg{mefa} and \pkg{mefa4} packages
to ensure that S3 and S4 objects are interchangeable (within certain computing limits).
<<results=hide>>=
as.stcs(x1)
as.mefa(x1)
as.stcs(x3)
(a <- as.mefa(x3))
xtab(a)
samp(a)
taxa(a)
segm(a)
segm(x3)
as.Mefa(a)
as.Xtab(a)
(s <- melt(a))
as.Xtab(s)
as.Mefa(s)
melt(x1)
melt(x3)
@

\section{Subsetting and replacement}

Accessing and replacing parts of the \code{"Mefa"} object
is conveniently done by methods \code{xtab}, \code{samp},
and \code{taxa} (the \code{segm} S3 method only returns the
code{xtab} slot):
<<>>=
xtab(x3)
x1[3,1] <- 999
xtab(x3) <- x1
xtab(x3)
@

Attribute tables can be set to \code{NULL}, or replaced:
<<>>=
samp(x3)
samp(x3) <- NULL
samp(x3)
samp(x3) <- samp[1:3,]
samp(x3)
@
<<results=hide>>=
taxa(x3)
taxa(x3) <- NULL
taxa(x3)
taxa(x3) <- taxa[1:3,]
taxa(x3)
@

Replacing parts of these attribute tables can be done as
<<>>=
samp(x3)[1,]
samp(x3)[1,2] <- 3
samp(x3)[1,]
@

Subsetting the whole \code{"Mefa"} object is done via the \code{[}
method:
<<>>=
unclass(x3[3:2, 1:2])
unclass(x3[3:2,])
unclass(x3[,1:2])
@

\section{Methods for S4 classes}

Simple methods are provided for convenience:
<<>>=
dim(x5)
dimnames(x5)
dn <- list(paste("S", 1:3, sep=""), paste("SPP", 1:4, sep=""))
dimnames(x5) <- dn
unclass(x5)
dimnames(x5)[[1]] <- paste("S", 1:3, sep="_")
unclass(x5)
dimnames(x5)[[2]] <- paste("SPP", 1:4, sep="_")
unclass(x5)
@

Transpose (I have never used it, but it was easy to implement):
<<>>=
x5
t(x5)
unclass(x5)
unclass(t(x5))
@

\section{\code{groupSums} and \code{groupMeans}}

The \code{aggregate} method was defined for 
S3 \code{mefa} objects. Its equivalent (although it cannot
sum the cells simultaneously for rows and columns, but
it was done in 2 steps anyways \ldots) is the
\code{groupSums} method. The \code{MARGIN} argument
indicates if rows (\code{MARGIN = 1}) or columns
(\code{MARGIN = 2}) are to be added together:
<<>>=
groupSums(as.matrix(x2), 1, c(1,1,2))
groupSums(as.matrix(x2), 2, c(1,1,2,2))
groupSums(x2, 1, c(1,1,2))
groupSums(x2, 2, c(1,1,2,2))
groupSums(x5, 1, c(1,1,2))
groupSums(x5, 2, c(1,1,2,2))
@
A simple extension of this is the \code{groupMeans}
method:
<<results=hide>>=
groupMeans(as.matrix(x2), 1, c(1,1,2))
groupMeans(as.matrix(x2), 2, c(1,1,2,2))
groupMeans(x2, 1, c(1,1,2))
groupMeans(x2, 2, c(1,1,2,2))
groupMeans(x5, 1, c(1,1,2))
groupMeans(x5, 2, c(1,1,2,2))
@

\section{Performace comparisons}

Now we compare the performance of the \pkg{mefa} and \pkg{mefa4}
packages. We are using a long formatted raw data file from the Alberta
Biodiversity Monitoring Institute database (available at \href{http://www.abmi.ca}{http://www.abmi.ca}):
<<>>=
data(abmibirds)
str(abmibirds)
@

This is the processing with \pkg{mefa}:
<<>>=
b3 <- abmibirds
b3 <- b3[!(b3$Scientific.Name %in% c("VNA", "DNC", "PNA")),]
levels(b3$Scientific.Name)[levels(b3$Scientific.Name) 
    %in% c("NONE", "SNI")] <- "zero.pseudo"
b3$Counts <- ifelse(b3$Scientific.Name == "zero.pseudo", 0, 1)
b3$Label <- with(b3, paste(ABMI.Site, Year, 
    Point.Count.Station, sep="_"))
x3 <- b3[!duplicated(b3$Label), c("Label", 
    "ABMI.Site", "Year", "Field.Date", 
    "Point.Count.Station", "Wind.Conditions", "Precipitation")]
rownames(x3) <- x3$Label
z3 <- b3[!duplicated(b3$Scientific.Name), c("Common.Name",
    "Scientific.Name", "Taxonomic.Resolution", 
    "Unique.Taxonomic.Identification.Number")]
rownames(z3) <- z3$Scientific.Name
z3 <- z3[z3$Scientific.Name != "zero.pseudo",]
t31 <- system.time(s3 <- suppressWarnings(stcs(b3[,
    c("Label","Scientific.Name","Counts")])))
t32 <- system.time(m30 <- mefa(s3))
t33 <- system.time(m31 <- mefa(s3, x3, z3))
y30 <- m30$xtab
t34 <- system.time(m32 <- mefa(y30, x3, z3))
m32
@

This is the processing with \pkg{mefa4}:
<<>>=
b4 <- abmibirds
b4$Label <- with(b4, paste(ABMI.Site, Year, 
    Point.Count.Station, sep="_"))
x4 <- b4[!duplicated(b4$Label), c("Label", "ABMI.Site", 
    "Year", "Field.Date", "Point.Count.Station",
    "Wind.Conditions", "Precipitation")]
rownames(x4) <- x4$Label
z4 <- b4[!duplicated(b4$Scientific.Name), c("Common.Name",
    "Scientific.Name", "Taxonomic.Resolution", 
    "Unique.Taxonomic.Identification.Number")]
rownames(z4) <- z4$Scientific.Name
t41 <- system.time(s4 <- Xtab(~ Label + Scientific.Name, 
    b4, cdrop = c("NONE", "SNI"), 
    subset = !(b4$Scientific.Name %in% c("VNA", "DNC", "PNA")), 
    drop.unused.levels = TRUE))
t42 <- system.time(m40 <- Mefa(s4))
t43 <- system.time(m41 <- Mefa(s4, x4, z4))
y40 <- as.matrix(m40@xtab)
t44 <- system.time(m42 <- Mefa(y40, x4, z4))
m42
sum(m42@xtab)
@

Let us compare object sizes and processing times:
<<echo=false>>=
res <- cbind("SIZE, *=3"=c("b*"=object.size(b3),
    "s*"=object.size(s3),
    "y*0"=object.size(y30),
    "m*0"=object.size(m30),
    "m*1"=object.size(m31),
    "m*2"=object.size(m32)),
"SIZE, *=4"=c("b*"=object.size(b4),
    "s*"=object.size(s4),
    "y*0"=object.size(y40),
    "m*0"=object.size(m40),
    "m*1"=object.size(m41),
    "m*2"=object.size(m42)),
"TIME, *=3"=c("b*"=NA,
    "s*"=t31[3],
    "y*0"=NA,
    "m*0"=t32[3],
    "m*1"=t33[3],
    "m*2"=t34[3]),
"TIME, *=4"=c("b*"=NA,
    "s*"=t41[3],
    "y*0"=NA,
    "m*0"=t42[3],
    "m*1"=t43[3],
    "m*2"=t44[3]))
(res <- cbind(res, "SIZE"=res[,2]/res[,1], "TIME"=res[,4]/res[,3]))
@
The compressed sparse matrix representation is 44\% of the \code{stcs} object in size.
\code{"Mefa"} object sizes are 15\% of the S3 representatives.
Processing time speed-up is enormous with sparse matrices, and still
quite high by standard matrices.

Make sure that objects are the same:
<<>>=
dim(y30)
dim(y40)
setdiff(rownames(y30), rownames(y40))
setdiff(rownames(y40), rownames(y30))
setdiff(colnames(y30), colnames(y40))
setdiff(colnames(y40), colnames(y30))
@

The aggregation also improved quite a bit:
<<>>=
system.time(xx3 <- aggregate(m31, "ABMI.Site"))
system.time(xx4 <- groupSums(m41, 1, m41@samp$ABMI.Site))
as.Mefa(xx3)
xx4
@

\section{Conclusions and outlook}

The redesign of the old S3 classes resulted in large savings in computing time
and object sizes. Old features are still available due to the free conversion
between the two implementations.

\end{document}
